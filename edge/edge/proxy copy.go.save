package edge

import (
	"context"
	"fmt"
	"net"
	"sync"
	"time"

	"github.com/danclive/nson-go"
	"github.com/quic-go/quic-go"
	"github.com/snple/types"
	"snple.com/kokomi/consts"
	"snple.com/kokomi/pb"
	"snple.com/kokomi/pb/edges"
	"snple.com/kokomi/util"
)

type ProxyListenerService struct {
	es *EdgeService

	listeners map[string]*proxyListener
	optLock   sync.RWMutex

	ctx     context.Context
	cancel  func()
	closeWG sync.WaitGroup
}

func newProxyListenerService(es *EdgeService) *ProxyListenerService {
	ctx, cancel := context.WithCancel(context.Background())

	return &ProxyListenerService{
		es:        es,
		listeners: make(map[string]*proxyListener),
		ctx:       ctx,
		cancel:    cancel,
	}
}

func (s *ProxyListenerService) getListener(proxyId string) types.Option[*proxyListener] {
	s.optLock.RLock()
	defer s.optLock.RUnlock()

	if pl, ok := s.listeners[proxyId]; ok {
		return types.Some(pl)
	}

	return types.None[*proxyListener]()
}

func (s *ProxyListenerService) setListener(proxyId string, pl *proxyListener) {
	s.optLock.Lock()
	defer s.optLock.Unlock()

	if pl, ok := s.listeners[proxyId]; ok {
		pl.cancel()
	}

	s.listeners[proxyId] = pl
}

func (s *ProxyListenerService) Start() {
	s.closeWG.Add(1)
	defer s.closeWG.Done()

	go s.waitDeviceUpdated()

	idle := time.NewTicker(time.Second * 30)
	defer idle.Stop()

	for {
		select {
		case <-s.ctx.Done():
			return
		case <-idle.C:
			func() {
				request := edges.ListProxyRequest{
					Page: &pb.Page{
						Limit: 100,
					},
				}

				reply, err := s.es.GetProxy().List(context.Background(), &request)
				if err != nil {
					s.es.Logger().Sugar().Fatal(err)
					return
				}

				for _, proxy := range reply.GetProxy() {
					option := s.getListener(proxy.GetId())
					if option.IsSome() {
						remoteIndex := genProxyIndex(proxy)
						index := genProxyIndex(option.Unwrap().proxy)
						if remoteIndex == index {
							continue
						}

						if proxy.Status == consts.ON {
							continue
						}

						if proxy.Network != "" && proxy.Address != "" && proxy.Target != "" {
							continue
						}

						option.Unwrap().cancel()
					}

					pl, err := startProxyListener(s, proxy)
					if err != nil {
						s.es.Logger().Sugar().Errorf("newProxyListener: %v", err)
						continue
					}

					s.setListener(proxy.GetId(), pl)
				}
			}()
		}
	}
}

func (s *ProxyListenerService) waitDeviceUpdated() {
	s.closeWG.Add(1)
	defer s.closeWG.Done()

	updated := int64(0)

	for {
		output := s.es.GetSync().WaitDeviceUpdated2(s.ctx)

		<-output
		err := s.syncProxy(s.ctx, &updated)
		if err != nil {
			s.es.Logger().Sugar().Errorf("device sync: %v", err)
		}

		ok := <-output
		if ok {
			err := s.syncProxy(s.ctx, &updated)
			if err != nil {
				s.es.Logger().Sugar().Errorf("device sync: %v", err)
			}
		} else {
			return
		}

		time.Sleep(time.Second)
	}
}

func (s *ProxyListenerService) syncProxy(ctx context.Context, updated *int64) error {
	proxyUpdated, err := s.es.GetSync().GetProxyUpdated(ctx, &pb.MyEmpty{})
	if err != nil {
		return err
	}

	if proxyUpdated.GetUpdated() <= *updated {
		return nil
	}

	{
		after := *updated
		limit := uint32(10)

		for {
			remotes, err := s.es.GetProxy().Pull(ctx, &edges.PullProxyRequest{After: after, Limit: limit})
			if err != nil {
				return err
			}

			for _, remote := range remotes.GetProxy() {
				after = remote.GetUpdated()

				if remote.GetDeleted() > 0 {
					option := s.getListener(remote.GetId())
					if option.IsSome() {
						option.Unwrap().cancel()
					}
				} else {
					option := s.getListener(remote.GetId())
					if option.IsSome() {
						remoteIndex := genProxyIndex(remote)
						index := genProxyIndex(option.Unwrap().proxy)
						if remoteIndex == index {
							continue
						}

						if remote.Status == consts.ON {
							continue
						}

						if remote.Network != "" && remote.Address != "" && remote.Target != "" {
							continue
						}

						option.Unwrap().cancel()
					}

					pl, err := startProxyListener(s, remote)
					if err != nil {
						s.es.Logger().Sugar().Errorf("newProxyListener: %v", err)
						continue
					}

					s.setListener(remote.GetId(), pl)
				}
			}

			if len(remotes.GetProxy()) < int(limit) {
				break
			}
		}
	}

	*updated = proxyUpdated.GetUpdated()

	return nil
}

func (s *ProxyListenerService) Stop() {
	s.cancel()
	s.closeWG.Wait()
}

type proxyListener struct {
	s        *ProxyListenerService
	proxy    *pb.Proxy
	listener net.Listener
	conns    map[string]net.Conn
	optLock  sync.RWMutex

	ctx    context.Context
	cancel func()
}

func startProxyListener(s *ProxyListenerService, proxy *pb.Proxy) (*proxyListener, error) {
	// The network must be "tcp", "tcp4", "tcp6", "unix" or "unixpacket".
	l, err := net.Listen(proxy.Network, proxy.Address)
	if err != nil {
		return nil, err
	}

	ctx, cancel := context.WithCancel(s.ctx)

	pl := &proxyListener{
		s:        s,
		proxy:    proxy,
		listener: l,
		conns:    make(map[string]net.Conn),
		ctx:      ctx,
		cancel:   cancel,
	}

	go pl.onCancel()
	go pl.accept()
	go pl.syncLinkStatus()

	return pl, nil
}

func (pl *proxyListener) accept() {
	defer pl.cancel()

	for {
		conn, err := pl.listener.Accept()
		if err != nil {
			return
		}

		go func() {
			err := pl.handleConn(conn)
			if err != nil {
				s.es.Logger().Sugar().Errorf("proxyListener.handleConn(conn) error: %v", err)
			}
		}()
	}
}

func (pl *proxyListener) handleConn(conn net.Conn) error {
	defer conn.Close()

	stream, err := GetQuic().OpenStreamSync()
	if err != nil {
		return err
	}
	defer stream.Close()

	err = pl.openProxy(stream)
	if err != nil {
		return err
	}

	addr := conn.RemoteAddr().String()

	pl.optLock.Lock()
	pl.conns[addr] = conn
	pl.optLock.Unlock()

	errChan := make(chan error)
	go GetQuic().StreamCopy1(stream, conn, errChan)
	go GetQuic().StreamCopy2(conn, stream, errChan)

	err = <-errChan
	if err != nil {
		s.es.Logger().Sugar().Errorf("stream.Copy error: %v", err)
	}

	<-errChan

	pl.optLock.Lock()
	delete(pl.conns, addr)
	pl.optLock.Unlock()

	return err
}

func (pl *proxyListener) openProxy(stream quic.Stream) error {
	{
		wmessage := nson.Message{
			"method": nson.String("proxy"),
			"proxy":  nson.String(pl.proxy.GetId()),
		}

		err := util.WriteNsonMessage(stream, wmessage)
		if err != nil {
			return err
		}
	}

	err := stream.SetReadDeadline(time.Now().Add(time.Duration(10) * time.Second))
	if err != nil {
		return err
	}

	{
		rmessage, err := util.ReadNsonMessage(stream)
		if err != nil {
			return err
		}

		code, err := rmessage.GetI32("code")
		if err != nil {
			return err
		}

		if code != 0 {
			return fmt.Errorf("rmessage: error code %v", code)
		}
	}

	err = stream.SetReadDeadline(time.Time{})
	if err != nil {
		return nil
	}

	return nil
}

func (pl *proxyListener) onCancel() {
	<-pl.ctx.Done()

	pl.listener.Close()

	pl.s.optLock.Lock()
	if _, ok := pl.s.listeners[pl.proxy.GetId()]; ok {
		delete(pl.s.listeners, pl.proxy.GetId())
	}
	pl.s.optLock.Unlock()

	pl.optLock.Lock()
	for _, conn := range pl.conns {
		conn.Close()
	}
	pl.optLock.Unlock()
}

func (pl *proxyListener) syncLinkStatus() {
	ticker := time.NewTicker(time.Duration(60) * time.Second)
	defer ticker.Stop()

	defer func() {
		request := edges.LinkProxyRequest{Id: pl.proxy.GetId(), Status: consts.OFF}

		ctx := context.Background()
		GetProxy().Link(ctx, &request)
	}()

	for {
		select {
		case <-pl.ctx.Done():
			return
		case <-ticker.C:
			{
				pl.optLock.RLock()
				n := len(pl.conns)
				pl.optLock.RUnlock()

				request := edges.LinkProxyRequest{Id: pl.proxy.GetId(), Status: int32(n)}

				ctx := context.Background()
				GetProxy().Link(ctx, &request)
			}
		}
	}
}

func genProxyIndex(proxy *pb.Proxy) string {
	return fmt.Sprintf("%v-%v-%v-%v",
		proxy.GetName(), proxy.GetNetwork(), proxy.GetAddress(), proxy.GetTarget())
}
